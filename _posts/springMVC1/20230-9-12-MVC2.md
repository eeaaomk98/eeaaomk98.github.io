---
published: true
layout: single
title: "스프링 MVC 1편 - 서블릿"
categories: spring
author_profile: false
typora-root-url: ../






---

해당 게시물은 인프런 김영한님의 스프링 MVC 1편을 참고하였습니다.

[인프런 김영한 님의 스프링 MVC 1편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1/dashboard)



-----------

이번 시간에는 **서블릿**에 대해 알아보자.

## 프로젝트 생성

https://start.spring.io 로 이동하여 프로젝트를 생성하자.

![image-20230912202552300](/../images/20230-9-12-MVC2/image-20230912202552300.png)

설정을 하고 Generate를 눌러 압축파일을 받아 압축을 해제하고 폴더의 build.gradle 파일을 IntelliJ를 통해 열어주었다. 

동작 확인을 위해 기본 메인 클래스인 `ServletApplication.main()`을 실행하고 http://localhost:8080으로 접속하여 Whitelabel Error Page가 나오는지 확인하였다.

그리고 File -> Setting으로 이동하여 Build and run을 Gradle에서 IntelliJ IDEA로 변경해주었다. 실행속도를 빠르게 하기 위함이다.

lombok도 적용해주었고, Postman도 다운로드 하였다. 

<br>

## Hello 서블릿

**스프링 부트 서블릿 환경 구성**

스프링 부트는 서블릿을 직접 등록해서 사용할 수 있도록 `@ServletComponentScan`을 지원한다. 이것을 추가해주었다.

`hello.servlet.ServletApplication`

```java
package hello.servlet;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.web.servlet.ServletComponentScan;

@ServletComponentScan //서블릿 자동 등록
@SpringBootApplication
public class ServletApplication {

	public static void main(String[] args) {
		SpringApplication.run(ServletApplication.class, args);
	}
}
```

<br>

**서블릿 등록하기**

`hello.servlet.basic.HelloServlet`

```java
package hello.servlet.basic;

...

@WebServlet(name = "helloServlet", urlPatterns = "/hello")
public class HelloServlet extends HttpServlet {

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        System.out.println("HelloServlet.service");
        System.out.println("request = " + request);
        System.out.println("response = " + response);

        String username = request.getParameter("username");
        System.out.println("username = " + username);

        response.setContentType("text/plain");
        response.setCharacterEncoding("utf-8");
        response.getWriter().write("hi " + username);
    }
```

- `@WebServlet` 서블릿 애노테이션
    - name : 서블릿 이름
    - urlPatterns : URL 매핑

HTTP 요청을 통해 매핑된 URL이 호출되면 서블릿 컨테이너는 위에 있는 `protected void service(HttpServletRequest request, HttpServletResponse response)`메서드를 실행한다.

- 웹 브라우저 실행
    - ![image-20230912204330979](/../images/20230-9-12-MVC2/image-20230912204330979.png)

- 콘솔 실행결과

- ```
    HelloServlet.service
    request = org.apache.catalina.connector.RequestFacade@19b39723
    response = org.apache.catalina.connector.ResponseFacade@59703c2d
    username = minki
    ```

<br>

**HTTP 요청 메시지 로그로 확인하기**

`application.properties`에 추가

```properties
logging.level.org.apache.coyote.http11=debug
```

서버를 재시작하고 요청해보면 서버가 받은 HTTP 요청 메시지 출력을 볼 수 있다.

```
Received [GET /hello?username=minki HTTP/1.1
Host: localhost:8080
Connection: keep-alive
Cache-Control: max-age=0
sec-ch-ua: "Chromium";v="116", "Not)A;Brand";v="24", "Google Chrome";v="116"
sec-ch-ua-mobile: ?0
sec-ch-ua-platform: "macOS"
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Sec-Fetch-Site: none
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Accept-Encoding: gzip, deflate, br
Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
Cookie: Idea-8a55a888=026e5936-7ca3-4433-af9d-75781e6e4a91
]
```

그런데 운영서버에 이렇게 모든 요청 정보를 다 남기면 성능저하가 발생할 수 있으므로 개발 단계에서만 적용하자.

<br>

## 서블릿 컨테이너 동작 방식

**내장 톰캣 서버 생성**

![image-20230912212113027](/../images/20230-9-12-MVC2/image-20230912212113027.png)

<br>

**HTTP 요청, HTTP 응답 메시지**

![image-20230912212135055](/../images/20230-9-12-MVC2/image-20230912212135055.png)

<br>

**웹 애플리케이션 서버의 요청 응답 구조**

![image-20230912212207928](/../images/20230-9-12-MVC2/image-20230912212207928.png)

<br>

## HttpServletRequest

**HttpServletRequest 역할**

서블릿은 개발자가 HTTP 요청 메시지를 편리하게 사용할 수 있도록 개발자 대신에 HTTP 요청 메시지를 파싱한다. 그리고 그 결과를 `HttpServletRequest`객체에 담아서 제공한다.

`HttpServletRequest`를 사용하면 HTTP 요청 메시지를 편리하게 조회할 수 있다.

```
POST /save HTTP/1.1
Host: localhost:8080
Content-Type: application/x-www-form-urlencoded
username=kim&age=20
```

- START LINE
    - HTTP 메소드
    - URL
    - 쿼리 스트링
    - 스키마, 프로토콜
- 헤더
    - 헤더 조회
- 바디
    - form 파라미터 형식 조회
    - message body 데이터 직접 조회

또한 `HttpServletRequest`객체는 임시 저장소 기능, 세션 관리 기능 등 여러가지 부가기능도 함께 제공한다.

**중요**

- `HttpServletRequest`, `HttpServletResponse`를 사용할 때 가장 중요한 점은 이 객체들이 HTTP 요청 메시지, HTTP 응답 메시지를 편리하게 사용하도록 도와주는 객체라는 점이다. 따라서 이 기능에 대해서 깊이있는 이해를 하려면 HTTP 스펙이 제공하는 요청, 응답 메시지 자체를 이해해야 한다.

<br>

## HTTP 요청 데이터 - 개요

HTTP 요청 메시지를 통해 클라이언트에서 서버로 데이터를 전달하는 주요 3가지 방법이 있다.

- **GET - 쿼리 파라미터**
    - /url**?username=hello&age=20**
    - 메시지 바디 없이, URL의 쿼리 파라미터에 데이터를 포함해서 전달
    - 예) 검색, 필터, 페이징등에서 많이 사용하는 방식
- **POST - HTML Form**
    - content-type : application/x-www-form-urlencoded
    - 메시지 바디에 쿼리 파라미터 형식으로 전달 username=hello&age=20
    - 예) 회원 가입, 상품 주문,  HTML Form 사용
- **HTML message body**에 데이터를 직접 담아서 요청
    - HTTP API에서 주로 사용, JSON, XML, TEXT
    - 데이터 형식은 주로  JSON 사용
    - POST, PUT, PATCH

<br>

### HTTP 요청 데이터 - GET 쿼리 파라미터

다음 데이터를 메시지 바디 없이, URL의 **쿼리 파라미터를 사용해서** 클라이언트에서 서버로 전송해보자.

- username = hello
- age = 20

쿼리 파라미터는 URL에 `?`를 시작으로 보낼 수 있고, 추가 파라미터는 `&`로 구분한다.

- http://localhost:8080/request-param?username=hello&age=20

서버에서는 `HttpServletRequest`가 제공하는 메서드를 통해 쿼리 파라미터를 편리하게 조회할 수 있다.

**쿼리 파라미터 조회 메서드**

```java
String username = request.getParameter("username"); //단일 파라미터 조회
Enumeration<String> parameterNames = request.getParameterNames(); //파라미터 이름들 모두 조회
Map<String, String[]> parameterMap = request.getParameterMap(); //파라미터를 Map 으로 조회
String[] usernames = request.getParameterValues("username"); //복수 파라미터 조회
```

<br>

`RequestParamServlet`

```java
package hello.servlet.basic.request;


import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * 파라미터 전송 기능
 * http://localhost:8080/request-param?username=hello&age=20
 */
@WebServlet(name = "requestParamServlet", urlPatterns = "/request-param")
public class RequestParamServlet extends HttpServlet {

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        System.out.println("[전체 파라미터 조회] - start");
        request.getParameterNames().asIterator()
                        .forEachRemaining(paramName -> System.out.println(paramName + "=" + request.getParameter(paramName)));
        System.out.println("[전체 파라미터 조회] - end");
        System.out.println();

        System.out.println("[단일 파라미터 조회]");
        String username = request.getParameter("username");
        String age = request.getParameter("age");

        System.out.println("username = " + username);
        System.out.println("age = " + age);
    }
}
```

`파라미터 전송을 한 결과 - http://localhost:8080/request-param?username=minki&age=22`

```
[전체 파라미터 조회] - start
username=minki
age=22
[전체 파라미터 조회] - end

[단일 파라미터 조회]
request.getParameter(username) = minki
request.getParameter(age) = 22
```

<br>

만약 `username=hello&username=minki`처럼 파라미터 값은 하나인데, 값이 중복이라면 `request.getParameterValues()`를 사용해야 한다. 중복일 때 `request.getParameter()`를 사용하면 `request.getParameterValues()`의 첫 번째 값을 반환한다.

<br>

### HTTP 요청 데이터 -  POST HTML Form

주로 회원 가입, 상품 주문 등에서 사용하는 방식이다.

**특징**

- content-type : application/x-www-form-urlencoded
- 메시지 바디에 쿼리 파라미터 형식으로 데이터를 전달한다. `username=hello&age=20`

<br>

`src/main/webapp/basic/hello-form.html`을 생성하여 접속하였다.

![image-20230912214948660](/../images/20230-9-12-MVC2/image-20230912214948660.png)

<br>

![image-20230913094247900](/../images/20230-9-12-MVC2/image-20230913094247900.png)

- POSTMAN을 통해 POST의 HTML Form을 전송하면 웹 브라우저는 다음 형식으로 HTTP 메시지를 만든다.
- **요청 URL** : http://localhost:8080/request-param
- **content-type** : application/x-www-form-urlencoded
- **message body** : username=hello&age=20

<br>

`application/x-www-form-urlencoded`형식은 앞서 GET에서 살펴본 파라미터 형식과 같다. 따라서 **쿼리 파타미터 조회 메서드를 그대로 사용**하면 된다. 서버 입장에서는 둘의 형식이 동일하므로, `request.getParameter()`로 편리하게 구분없이 조회할 수 있다.

정리하면 `request.getParameter()`는 GET URL 쿼리 파라미터 형식도 지원하고, POST HTML Form 형식도 둘 다 지원한다.

<br>

## HTTP 요청 데이터 - API 메시지 바디 - 단순 텍스트

- **HTTP message body**에 데이터를 직접 담아서 요청
- HTTP API에서 주로 사용, JSON, XML, TEXT
- 데이터 형식은 주로 JSON 사용
- POST, PUT, PATCH

<br>

`RequestBodyStringServlet`

```java
package hello.servlet.basic.request;

...

@WebServlet(name = "requestBodyStringServlet", urlPatterns = "/request-body-string")
public class RequestBodyStringServlet extends HttpServlet {

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        ServletInputStream inputStream = request.getInputStream();
        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);

        System.out.println("messageBody = " + messageBody);

        response.getWriter().write("success");
    }
}
```

> **참고**
>
> HTTP 메시지 바디의 데이터를 inputStream을 사용해서 직접 읽을 수 있다.
>
> inputStream은  byte코드를 반환한다.  byte코드를 우리가 읽을 수 있는 문자로 보려면 인코딩 정보를 지정해주어야 한다. 여기서는 UTF-8로 지정해주었다.

**문자 전송**

![image-20230913095309534](/../images/20230-9-12-MVC2/image-20230913095309534.png)

결과로 `messageBody`에 `hi minki`가 저장된다.

<br>

## HTTP 요청 데이터 - API 메시지 바디 -  JSON

**JSON형식 전송**

- POST : http://localhost:8080/request-body-json
- content-type : **application/json**
- message body : {"username": "hello", "age": 20}
- 결과 : message body = {"username": "hello", "age": 20}

<br>

**JSON형식 파싱 추가**

`hello.servlet.basic.HelloData`

```java
package hello.servlet.basic;

import lombok.Getter;
import lombok.Setter;

@Getter @Setter
public class HelloData {

    private String username;
    private int age;

}
```

```java
package hello.servlet.basic.request;

...

@WebServlet(name = "requestBodyJsonServlet", urlPatterns = "/request-body-json")
public class RequestBodyJsonServlet extends HttpServlet {

    private ObjectMapper objectMapper = new ObjectMapper();

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        ServletInputStream inputStream = request.getInputStream();
        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);

        System.out.println("messageBody = " + messageBody);
        HelloData helloData = objectMapper.readValue(messageBody, HelloData.class);

        System.out.println("helloData.Username() = " + helloData.getUsername());
        System.out.println("helloData.age() = " + helloData.getAge());

        response.getWriter().write("wow");
    }
}
```

JSON 결과를 파싱해서 사용할 수 있는 자바 객체로 변환하려면 Jackson, Gson 같은 JSON 변환 라이브러리를 추가해서 사용해야 한다. 스프링 부트로 Spring MVC를 선택하며 기본으로  Jackson라이브러리(`ObjectMapper`)를 함께 제공한다.

**Postman으로 실행**

![image-20230913104124089](/../images/20230-9-12-MVC2/image-20230913104124089.png)

<br>

**출력결과**

```
messageBody = {"username":"minki", "age":"20"}
helloData.Username() = minki
helloData.age() = 20
```

<br>

## HttpServletResponse - 기본 사용

- **HTTP 응답 메시지 생성**
- HTTP 응답코드 지정
- 헤더 생성
- 바디 생성

`hello.servlet.basic.response.ResponseHeaderServlet`

```java
package hello.servlet.basic.response;

...

@WebServlet(name = "responseHeaderServlet", urlPatterns = "/response-header")
public class ResponseHeaderServlet extends HttpServlet {
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //[status-line]
        response.setStatus(HttpServletResponse.SC_OK);

        //[response-headers]
        response.setHeader("Content-Type", "text/plain;charset=utf-8");
        response.setHeader("Cache-Control", "no-cache, no-store, must-revalidate");
        response.setHeader("Pragma", "no-cache");
        response.setHeader("my-header", "hellominki");

        PrintWriter writer = response.getWriter();
        writer.println("안녕하세");
    }
}
```

<br>

## HTTP 응답 데이터 - 단순 텍스트, HTML

- 단순 텍스트 응답
- HTML응답
- HTTP API - MessageBody JSON 응답

`hello.servlet.web.response.ResponseHtmlServlet` - HTML 응답

```java
package hello.servlet.basic.response;

...

@WebServlet(name = "responseHtmlServlet", urlPatterns = "/response-html")
public class ResponseHtmlServlet extends HttpServlet {
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // Content-Type : text/html;charset-utf-8
        response.setContentType("text/html");
        response.setCharacterEncoding("utf-8");

        PrintWriter writer = response.getWriter();
        writer.println("<html>");
        writer.println("<body>");
        writer.println(" <div>안녕?</div>");
        writer.println("</body>");
        writer.println("</html>");
    }
}
```

<img src="/../images/20230-9-12-MVC2/image-20230913105512244.png" alt="image-20230913105512244" style="zoom:67%;" />

<br>

## HTTP 응답 데이터 - API JSON

`hello.servlet.web.response. ResponseJsonServlet`

```java
package hello.servlet.basic.response;

import com.fasterxml.jackson.databind.ObjectMapper;
import hello.servlet.basic.HelloData;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet(name = "responseJsonServlet", urlPatterns = "/response-json")
public class ResponseJsonServlet extends HttpServlet {

    private ObjectMapper objectMapper = new ObjectMapper();

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //Content-Type : application/json
        response.setContentType("application/json");
        response.setCharacterEncoding("utf-8");

        HelloData helloData = new HelloData();
        helloData.setUsername("minki");
        helloData.setAge(25);

        //{"username":"minki", "age":25}
        String result = objectMapper.writeValueAsString(helloData);
        response.getWriter().write(result);

    }
}
```

HTTP 응답으로  JSON을 반환할 때는 content-type을 `application/json`으로 지정 해야 한다. Jackson 라이브러리가 제공하는 `objectMapper.writeValueAsString()`를 사용하면 객체를  JSON문자로 변경할 수 있다.




---
layout: single
title:  "HTTP 웹 기본지식"
categories: Network
tag: [network, http, back-end]
author_profile: false

---

# 인터넷 네트워크에 대해

## 인터넷에서 컴퓨터 둘은 어떻게 통신할까 ?

<img width="815" alt="스크린샷 2023-06-03 시간: 13 11 40" src="https://github.com/eeaaomk98/eeaaomk98.github.io/assets/134247168/3b964cbb-f7f2-4276-8b81-f6e9adab3b93">

`Hello, world!`메시지를 전달받는 PC가 멀리 있다면 인터넷 망에 있는 노드(인터넷에 연결되어 있는 기기) 통해서 메시지를 보내야 한다. 이 노드들을 통해 메시지를 안전하게 상대방 컴퓨터에 전송해야 하는데, 그것을 이해하려면 `IP(Internet Protocol)`에 대한 이해가 필요하다.

## IP(인터넷 프로토콜)

복잡한 인터넷망에서 `Hello, world!`메시지를 보내려면 최소한의 어떤 규칙이 필요하다. 이것을 IP주소 부여를 통해 해결할 수 있다.

<img width="830" alt="image" src="https://github.com/eeaaomk98/eeaaomk98.github.io/assets/134247168/dda65243-c1c7-42ce-b18f-63d2d42f865a">

IP 프로토콜은 

- 지정한 IP주소에 데이터 전달
- 패킷(Packet)이라는 통신 단위로 데이터 전달의 기능이 있다.



<br>





<img width="803" alt="image" src="https://github.com/eeaaomk98/eeaaomk98.github.io/assets/134247168/7abf5439-f1a5-4ed1-ab9c-69f2217b80da">

데이터를 그냥 보내는 것이 아니라 `IP 패킷이라는 규칙`을 적용해서 전송하게 되는데, IP패킷에   `데이터와 출발지 IP, 목적지 IP`를 함께 적어 전송하게 된다. 마치 편지를 보낼 때 편지지(데이터)를 편지봉투에 넣고 보내는 사람 주소, 받는 사람 주소를 적는 것과 같다. 이 IP패킷을 인터넷 망에 보내면 서버들이 IP프로토콜 규약에 의해 패킷을 받을 수 있는 노드로 전송되면서, 목적지에 도착하게 된다. 그리고 클라이언트에서 서버로 데이터를 보낼 때와, 서버에서 클라이언트로 데이터를 보낼 때는 서로 다른 경로로 전송될 수 있다.



하지만 이런 방식만으로는 한계가 있다.

## IP 프로토콜의 한계

- **비연결성**
  - 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송
- **비신뢰성**
  - 중간에 패킷이 사라질 수 있다.
  - 패킷이 순서대로 오지 않을 수 있다.
- **프로그램 구분**
  - 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이라면 ?



## TCP와 UDP

TCP와 UDP를 적용하면 IP프로토콜의 문제점을 극복할 수 있다.

<img width="770" alt="스크린샷 2023-06-03 오후 1 33 06" src="https://github.com/eeaaomk98/eeaaomk98.github.io/assets/134247168/2f9882bb-bdb3-4c99-85d6-d87da32c367b">

채팅프로그램으로 해외에 있는 친구에게 `Hello, world!`메시지를 보내려고 할 때, 

1. 프로그램이 Hello, world! 메시지를 생성하고
2. SOCKET 라이브러리를 통해 OS계층에 메시지를 전달한다.
3. OS계층에서 TCP정보로 메시지를 감싼다.
4. TCP정보로 감싼 메시지를 IP정보와 함께 한 번 더 감싸 IP패킷을 생성하고, LAN카드를 통해서 나갈 때, Ethernet frame(MAC주소 등 물리적 정보)이 포함되어 전송이 된다.



<img width="712" alt="스크린샷 2023-06-03 오후 1 39 08" src="https://github.com/eeaaomk98/eeaaomk98.github.io/assets/134247168/926b11f5-e925-478a-80de-cc3e6961b196">

이 TCP/IP 프로토콜은 IP프로토콜만으로 해결되지 않았던 전송 제어나, 순서 등 문제를 해결할 수 있다.

### TCP 특징

전송 제어 프로토콜(Transmission Control Protocol)

- 연결지향 - TCP 3 way handshake(가상 연결)

  <img width="758" alt="스크린샷 2023-06-03 오후 1 43 06" src="https://github.com/eeaaomk98/eeaaomk98.github.io/assets/134247168/7adff278-ace4-4a38-aa4e-03c11d261b7d">

- 데이터 전달 보증

  - 클라이언트에서 데이터를 전송하면, 서버는 데이터를 잘 받았다고 메시지를 보내주어서, 클라이언트가 보낸 데이터가 잘 전달되었는지 확인이 가능하다.

- 순서 보장

- 신뢰할 수 있는 프로토콜
- 현재는 대부분 TCP 사용



<br>



### UDP 특징

사용자 데이터그램 프로토콜(User Datagram Protocol)

- 데이터 전달 및 순서가 보장되지 않지만, 단순하고 빠르다
- IP와 거의 같다. +PORT + 체크섬 정도만 추가한다.
- 애플리케이션에서 추가 작업이 필요하다.



<br>



## PORT

<img width="738" alt="image" src="https://github.com/eeaaomk98/eeaaomk98.github.io/assets/134247168/d24670c0-951b-458c-b787-5dd2661b7fb9">



- 0~65535 할당 가능
- 0~1023: 잘 알려진 포트, 사용하지 않는 것이 좋음
  - FTP - 20, 21
  - TELNET - 23
  - HTTP - 80
  - HTTPS - 443



## DNS(Domain Name System)

IP주소는 기억하기 어렵고, 변경될 수 있기 때문에 도메인 이름과 IP주소를 매핑시켜서 기억하기 쉽게 해주는 것이 DNS이다.

<img width="766" alt="image" src="https://github.com/eeaaomk98/eeaaomk98.github.io/assets/134247168/6edb1c3d-b31c-4ed9-ad3b-e818399d5330">





<br>



## URL 문

```
https://www.google.com:443/search?q=hello&hl=ko
```



- https - 프로토콜이 들어가는 자리이다.. ex) http, https, ftp 등
- www.google.com - 호스트명이다. 도메인명 또는 IP주소를 직접 사용가능
- :443 - 포트(PORT)이다. 접속 포트이며, 일반적으로는 생략한다.
- search - 리소스 경로(path)이다. 계측정 구조이다.
- ?q=hello&hl=ko - query이고, key=value 형태이다. ?로 시작하고, &로 추가할 수 있다. query parameter등으로 불린다.



<br>





# 웹 브라우저의 흐름

주소창에 `https://www.google.com/search?q=hello&hl=ko`라고 입력을 하면

<img width="799" alt="image" src="https://github.com/eeaaomk98/eeaaomk98.github.io/assets/134247168/c0d3cd99-bd31-48cc-aea3-5c09fe1cb3b5">

웹 브라우저는 DNS서버를 조회해서 IP주소와 PORT번호를 찾아낸다. 그리고 HTTP요청 메시지를 생성(`GET/search?q=hello&hl=ko HTTP/1.1 HOST:www.google.com`)한다.

## HTTP 메시지 전송

<img width="727" alt="image" src="https://github.com/eeaaomk98/eeaaomk98.github.io/assets/134247168/9f081861-5270-4e15-84ca-5586aca9782f"> 



<img width="818" alt="스크린샷 2023-06-03 오후 6 44 49" src="https://github.com/eeaaomk98/eeaaomk98.github.io/assets/134247168/394c85fb-24ae-4a1d-9f3f-08ae0950cb2b">

패킷이 생성되면, HTTP메시지를 감싸서 요청 패킷을 전달한다. 패킷이 서버에 도착하면, 서버는 HTTP응답 메시지를 만들어서 다시 웹 브라우저로 전송하여서 웹 브라우저는 그에 맞는 HTML렌더링을 하여 결과를 보여준다.



<br>



<br>

# HTTP 기본

### 모든 것이 HTTP - HTTP 메시지에 모든 것을 전송

- HTML, TEXT
- IMAGE, 음성, 영상, 파일
- JSON, XML(API)
- 거의 모든 형태의 데이터 전송 가능
- 서버간에 데이터를 주고 받을 때도 대부분을 HTTP 사용
- **지금은 HTTP 시대 !**



### HTTP 역사

- HTTP/1.1 1997년 : 가장 많이 사용, 우리에게 가장 중요한 버전 - TCP 기반
- HTTP/2 2015년 : 성능 개선 - TCP 기반
- HTTP/3 진행중 : TCP 대신에 UDP 사용, 성능 개선 - UDP 기반



### HTTP 특징

- 클라이언트 서버 구조
- 무상태 프로토콜(스테이스리스), 비연결성
- HTTP 메시지
- 단순함, 확장 가능



### 클라이언트 서버 구조

- Request Response 구조
- 클라이언트는 서버에 요청을 보내고, 응답을 대기
- 서버가 요청에 대한 결과를 만들어서 응답



## Stateful, Stateless 차이

### 상태 유지 - Stateful 

- 항상 같은 서버가 유지되어야 한다. 중간에 서버가 장애가 난다면 클라이언트 A는 처음부터 다시 작업을 수행해야 한다.



### 무상태 - Stateless

- 아무 서버나 호출해도 된다. 중간에 서버가 장애가 난다면 다른 서버로 전달해주면 된다.
- 수평 확장(스케일 아웃)에 유리하다. 



<br>

## 비 연결성(connectionless)

-  HTTP는 기본이 연결을 유지하지 않는 모델
- 일반적으로 초 단위의 이하의 빠른 속도로 응답
- 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작음
- 서버 자원을 매우 효율적으로 사용할 수 있음



#### 비 연결성의 한계와 극복

- TCP/IP 연결을 새로 맺어야 함 - 3way handshake 시간이 추가됨.
- 웹 브라우저로 사이트를 요청하면 HTML뿐만 아니라 자바스크립트, css, 추가 이미지 등 수 많은 자원이 함께 다운로드 된다.
- 지금은 HTTP 지속 연결(Persistent Connection)로 문제를 해결하였다.
- HTTP/2, HTTP/3에서는 더 많은 최적화가 이루어졌다.



<br>



## HTTP 메시지

<img width="843" alt="image" src="https://github.com/eeaaomk98/eeaaomk98.github.io/assets/134247168/d075e696-6820-41dc-a981-489b8be42b83">

<br>

### 시작 라인의 요청 메시지 - HTTP 메서드

<img width="335" alt="image" src="https://github.com/eeaaomk98/eeaaomk98.github.io/assets/134247168/1f2376b1-7226-4a77-ae32-fcb6a08c82ef">

- 종류 : GET, POST, PUT, DELETE...

- 서버가 수행해야 할 동작 지정
  - GET : 리소스 조회
  - POST : 요청 내역 처리 



<br>



### 시작 라인의 요청 메시지 - 요청 대상

<img width="413" alt="image" src="https://github.com/eeaaomk98/eeaaomk98.github.io/assets/134247168/4865b9b0-afa3-4ecb-80b3-67e7e6a0d905">

- `absolute-path[?query](절대경로[?쿼리])`
- 절대경로= "/" 로 시작하는 경로



### 시작 라인의 요청 메시지 - HTTP 버전

<img width="346" alt="image" src="https://github.com/eeaaomk98/eeaaomk98.github.io/assets/134247168/d03667d3-faef-43ba-b08d-93c6d623a9c1">



<br>



### 시작 라인의 응답 메시지

<img width="390" alt="image" src="https://github.com/eeaaomk98/eeaaomk98.github.io/assets/134247168/effc4123-13af-4dab-b032-b3a3bf99e4e5">

- **status-line** = HTTP - version (SPACE_BAR) status-code (SPACE_BAR) reason-phrase CRLF
- HTTP 상태 코드 : 요청 성공, 실패를 나타냄ㅁ
  - 200 : 성공
  - 400 : 클라이언트 요청 오류
  - 500 : 서버 내부 오류
- 이유 문구 : 사람이 이해할 수 있는 짧은 상태 코드 설명 글



<br>



### HTTP 헤더

<img width="745" alt="image" src="https://github.com/eeaaomk98/eeaaomk98.github.io/assets/134247168/ea4fbd16-99a0-482d-aeac-e3fcb6f9641c">

- header-field = field-name":" OWS field-value OWS
- field-name은 대소문자 구분 없음



### HTTP 헤더 용도

- HTTP 전송에 필요한 모든 부가정보가 들어가있다.
- 예) 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트(브라우저)정보, 서버 애플리케이션 정보, 캐시 관리 정보..
- 표준 헤더가 많다.
- 필요시 임의의 헤더 추가 가능



### HTTP 메시지 바디 용도

<img width="357" alt="image" src="https://github.com/eeaaomk98/eeaaomk98.github.io/assets/134247168/5b0b95d6-144e-424e-88ff-45170aa0eb0b">

- 실제 전송할 데이터가 들어간다.
- HTML문서, 이미지, 영상, JSON등등 byte로 표현하라 수 있는 모든 데이터를 전송할 수 있다.



<br>



# HTTP 메서드



## HTTP API를 만들어보자.

### API URI 고민

- 리소스의 의미는 뭘까?
  - 회원을 등록하고 수정하고 조회하는게 리소스가 아니라 **회원이라는 개념 자체가 바로 리소스다.**
- 리소스를 어떻게 식별하는게 좋을까 ?
  - **회원이라는 리소스만 식별하면 된다. -> 회원 리소스를 URI에 매핑**



### 리소스와 행위를 분리 - 가장 중요한 것은 리소스를 식별하는 것

- **URI는 리소스만 식별!**
- **리소스**와 해당 리소스를 대상으로 하는 **행위**를 분리
  - 리소스 : 회원
  - 행위 : 조회, 등록, 삭제, 변경
- 리소스는 명사, 행위는 동사(미네랄을 캐라)
- 행위(메서드)는 어떻게 구분할까 ?



## HTTP 메서드 -  GET, POST

### HTTP 메서드 종류 - 주요 메서드

- GET : 리소스 조회
- POST : 요청 데이터 처리, 주로 등록에 사용
- PUT : 리소스를 대체, 해당 리소스가 없으면 생성
- PATCH : 리소스 부분 변경
- DELETE : 리소스 삭제



<br>

### GET

- 리소스 조회
- 서버에 전달하고 싶은 데이터는 query를 통해서 전달



### POST

- 요청 데이터 처리
- **메시지 바디를 통해 서버로 요청 데이터 전달**
- 서버는 요청 데이터를 **처리**
  - 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다.
- 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용
- 정리 : 1. 새 리소스 생성(등록)  2. 요청 데이터 처리 3. 다른 메서드로 처리하기 애매한 경우



### PUT

- **리소스를 대체**한다.
  - 리소스가 있으면 대체
  - 리소스가 없으면 생성
  - 쉽게 이야기해서 덮어버림
- **중요 ! 클라이언트가 리소스를 식별하고 있다.**
  - 클라이언트가 리소스 위치를 알고 URI 지정한다. 이것이 POST와의 차이점이다.



### PATCH

- 리소스 부분 변경



### DELETE

- 리소스 제거



<br>



## HTTP 메서드의 속성

- 안전(Safe Methods)
  - 호출해도 리소스를 변경하지 않는다. (GET, HEAD)
- 멱등(Idempotent Methods)
  - 한 번 호출하든 100번 호출하든 결과가 똑같다. (GET, PUT, DELETE)
  - 활용 : 자동 복구 메커니즘
- 캐시가능(Cacheable Methods)
  - 응답 결과 리소스를 캐시해서 사용해도 되는가 ? 
  - 실제로는 GET, HEAD 정도만 캐시로 사용한다.





























